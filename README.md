# Order Service

This service aims to persist an order with its respective products to later carry out the processing through an automated job and make the result available in a query API in the REST standard.

## Stack
* **Java 21**
* **Spring Boot 3**
* **Spring Data**
* **Spring Batch**
* **Spring Web MVC**
* **Hibernate**
* **Swagger 3**
* **PostgreSQL**
* **Shedlock**

## Prerequisites
* **JDK 21**
* **Gradle**
* **Git**
* **Docker**
* **Docker compose**

## Running the project
After cloning the project, it is necessary to use Docker Compose to upload a local database. Use the following command
```
sudo docker compose up
```

## Swagger docs
http://localhost:8080/swagger-ui/index.html

## Order model

*The "externalId" field is used to check duplicate requests, being a unique identifier managed by the producing API*
```json
{
  "id": 1,
  "externalId": 4,
  "createdDate": "2024-11-21T17:34:14.325704Z",
  "orderStatus": "PROCESSED",
  "lastModifiedDate": "2024-11-21T17:35:00.099713Z",
  "totalAmount": 45.00,
  "products": [
    {
      "id": 1,
      "description": "Product 1",
      "amount": 10.00
    },
    {
      "id": 2,
      "description": "Product 2",
      "amount": 15.00
    },
    {
      "id": 3,
      "description": "Product 3",
      "amount": 20.00
    }
  ]
}
```

## Payload Examples (cUrl)

* Get orders paginated
```
curl --location 'http://localhost:8080/orders?page=0&size=10'
```
* Save an order
```
curl --location 'http://localhost:8080/orders' \
--header 'Content-Type: application/json' \
--data '{
    "externalId": 4,
    "products": [
        {
            "description": "Product 1",
            "amount": 10
        },
        {
            "description": "Product 1",
            "amount": 15
        },
        {
            "description": "Product 1",
            "amount": 20
        }
    ]
}'
```
## Project considerations

* The project aims to process an order asynchronously, making the order persist as quickly and consistently as possible to be processed later through a job using "cron" and managed by pre-defined statuses. The choice of relational database was PostgreSQL due to its great robustness and compliance with ACID principles, in addition to its great acceptance and support by the market.


* The service can be scaled horizontally and vertically depending on the need, just paying attention to the job execution rules (state sharing) between existing replicas in order to avoid any competition between writing and reading data.


* The database can be divided between two instances for reading and writing data in order to promote greater fluidity and agility in processing, however any inconsistency generated by this must be taken into account.


* The SQL query made by the job can be improved in order to avoid extra queries during the process.


* Another future point of improvement would be the development of reprocessing of orders that were not processed normally.


* Message queues are great ways to communicate to an external service when an asynchronous process has finished being carried out. Instead of the internal service consuming our API, we would play the role of producer to send the processing result.